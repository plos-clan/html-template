<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2048 Game - Hexadecimal Edition</title>
  <script src="tailwindcss.js"></script>
  <script defer src="alpinejs.js"></script>
  <style>
    [x-cloak] {
      display: none !important;
    }

    body {
      user-select: none;

      font-family: monospace !important;
    }

    input[type="text"] {
      outline: none;
    }

    input[type="text"]:focus {
      color: darkcyan;
    }

    input[type="text"]::selection {
      color: darkcyan;
      background: #ffcc00;
    }

    textarea {
      outline: none;
    }

    textarea.serialization {
      width: 100%;
      height: 10em;
      font-size: medium;
      resize: none !important;
    }

    textarea.serialization:focus {
      color: darkcyan;
    }

    textarea.serialization::selection {
      color: darkcyan;
      background: #ffcc00;
    }
  </style>
</head>

<body x-data="game()" x-init="initGame()" class="bg-gray-100 min-h-screen flex items-center justify-center">
  <div class="p-4 bg-white rounded-lg shadow-lg" @keydown.window="handleKeyPress($event)">
    <h1 class="text-3xl font-bold text-center mb-4" @click="$nextTick(() => { showSettings = true })">
      2048 - Hex Edition
    </h1>
    <template x-if="showBoardSizeSlider">
      <input type="range" id="boardSize" x-model="newBoardSize" min="4" max="32" step="1" @change="resetGame()"
        class="w-full sm:w-64" :disabled="isEditMode || autoMoveInterval">
    </template>
    <div class="mb-4 flex flex-wrap justify-between items-center">
      <template x-if="showBoardSize || boardSize !== parseInt(newBoardSize)">
        <div class="mb-2">
          <label for="boardSize" class="mr-2">Size:
            <span x-text="`0x${parseInt(newBoardSize).toString(16).toUpperCase()}`"></span>
          </label>
        </div>
      </template>
      <div></div>
      <template x-if="showScore && !isEditMode">
        <div class="text-xl font-bold">Score: <span x-text="`0x${score.toString(16).toUpperCase()}`"></span></div>
      </template>
      <template x-if="showScore && isEditMode">
        <div class="text-xl font-bold">Score: <input type="text" class="bg-transparent text-center edit-cell"
            maxlength="11" size="11" style="width: 11ch;" x-model="scoreHex"
            @input="editModeScoreInput($event.target.value)" @focus="$event.target.select()" /></div>
      </template>
    </div>
    <div class="grid gap-2" :style="`grid-template-columns: repeat(${boardSize}, minmax(0, 1fr));`"
      @touchstart="handleTouchStart($event)" @touchend="handleTouchEnd($event)">
      <template x-for="(row, rowIndex) in board" :key="rowIndex">
        <template x-for="(cell, cellIndex) in row" :key="cellIndex">
          <div class="w-16 h-16 flex items-center justify-center text-xl font-bold rounded-lg"
            :class="getCellClass(cell)" :style="getCellStyle(cell) + 'position: relative;'">
            <template x-if="!isEditMode">
              <span x-html="cell ? getCellText(cell) : ''"></span>
            </template>
            <template x-if="isEditMode">
              <div class="absolute inset-0" style="background: transparent;"
                @click.prevent="$el.closest('.flex').querySelector('input').focus()"
                @contextmenu.prevent="editModeSetVal(rowIndex, cellIndex, 0); $el.closest('.flex').querySelector('input').blur()">
              </div>
            </template>
            <template x-if="isEditMode">
              <span>2<sup><input type="text" class="bg-transparent text-center edit-cell" maxlength="2" size="2"
                    style="width: 2ch;" x-model="editBoard[rowIndex][cellIndex]"
                    @contextmenu.prevent="editModeSetVal(rowIndex, cellIndex, 0); $el.blur()"
                    @input="editModeInput(rowIndex, cellIndex, $event.target.value)"
                    @focus="$nextTick(() => $event.target.select())" /></sup></span>
            </template>
            <template x-if="isEditMode && cell == 0">
              <div class="absolute inset-0 z-10" style="background: transparent;"
                @click.prevent="editModeSetVal(rowIndex, cellIndex, 1); $el.closest('.flex').querySelector('input').focus()"
                @contextmenu.prevent="">
              </div>
            </template>
          </div>
        </template>
      </template>
    </div>
    <div class="mt-4 text-center">
      <template x-if="showUndoRedo">
        <button @click="undo()" class="text-white font-bold py-1.5 px-3 rounded"
          :class="autoMoveInterval || undoStack.length == 0 ? 'bg-gray-500' : 'bg-blue-500 hover:bg-blue-600'"
          :disabled="autoMoveInterval || undoStack.length == 0">
          Undo
        </button>
      </template>
      <button @click="toggleAutoMove()" class="text-white font-bold py-1.5 px-3 rounded"
        :class="isEditMode ? 'bg-gray-500' : 'bg-blue-500 hover:bg-blue-600'" :disabled="isEditMode">
        Auto
      </button>
      <button @click="resetGame()" class="text-white font-bold py-1.5 px-3 rounded"
        :class="isEditMode ? 'bg-gray-500' : 'bg-blue-500 hover:bg-blue-600'" :disabled="isEditMode">
        New
      </button>
      <button @click="toggleEditMode()" class="text-white font-bold py-1.5 px-3 rounded"
        :class="autoMoveInterval ? 'bg-gray-500' : 'bg-blue-500 hover:bg-blue-600'" :disabled="autoMoveInterval">
        Edit
      </button>
      <template x-if="showUndoRedo">
        <button @click="redo()" class="text-white font-bold py-1.5 px-3 rounded"
          :class="autoMoveInterval || redoStack.length == 0 ? 'bg-gray-500' : 'bg-blue-500 hover:bg-blue-600'"
          :disabled="autoMoveInterval || redoStack.length == 0">
          Redo
        </button>
      </template>
    </div>
  </div>
  <div
    class="absolute inset-0 z-10 bg-black bg-opacity-30 opacity-0 flex items-center justify-center transition-all duration-300 ease-in-out"
    :style="`opacity: ${ showSettings ? '1' : '0' }; ${ showSettings ? '' : 'pointer-events: none;' } backdrop-filter: blur(2px);`">
    <div class="bg-white rounded-lg shadow-lg text-lg"
      @click.away="if (!showSerialization && !showGameOver) showSettings = false">
      <div class="mb-4 border-b border-gray-200">
        <ul class="flex flex-wrap -mb-px text-sm font-medium text-center">
          <template x-for="tab in ['教程', '排行', '设置']" :key="tab">
            <li class="ml-1 mr-1">
              <button class="inline-block p-4 rounded-t-lg border-b-2"
                :class="{'border-blue-600 text-blue-600': activeTab === tab, 'border-transparent text-gray-500 hover:text-gray-600 hover:border-gray-300': activeTab !== tab}"
                @click="activeTab = tab" type="button" role="tab" x-text="tab">
              </button>
            </li>
          </template>
          <li class="ml-auto mr-1">
            <button class="inline-block p-4 rounded-t-lg border-transparent text-gray-500 hover:text-red-500"
              @click="showSettings = false" type="button" role="tab">
              关闭
            </button>
          </li>
        </ul>
      </div>
      <div class="p-4 pt-0">
        <template x-if="activeTab === '教程'">
          <div>
            <h2 class="text-xl font-bold mb-4">2048 游戏教程</h2>
            <p class="mb-2">欢迎来到 2048 游戏！以下是一些简单的游戏规则和操作指南：</p>
            <ol class="list-decimal list-inside mb-4">
              <li>使用键盘上的箭头键（↑, ↓, ←, →）来移动方块。</li>
              <li>每次移动时，所有方块都会向指定方向滑动。</li>
              <li>当两个相同数字的方块碰撞时，它们会合并成一个新的方块，数字相加。</li>
              <li>目标是创建一个数字为 0x800 的方块。</li>
            </ol>
            <p class="mb-2">提示：</p>
            <ul class="list-disc list-inside">
              <li>尽量保持较大的数字在角落。</li>
              <li>提前规划每一步的移动，避免无效操作。</li>
            </ul>
            <p class="mt-4">祝你好运，享受游戏的乐趣吧！</p>
            <p class="text-right text-sm text-gray-500">The above content is generated by Github Copilot.</p>
          </div>
        </template>
        <template x-if="activeTab === '排行'">
          <div>
            <div class="mb-4 flex flex-wrap justify-between items-center">
              <h2 class="text-xl font-bold">2048 排行榜</h2>
              <button class="ml-2 text-blue-400 hover:text-blue-600" @click="downloadLeaderboard()">
                刷新
              </button>
            </div>
            <div style="width: 300px;"></div>
            <template x-if="leaderboard.length === 0">
              <p>暂无数据</p>
            </template>
            <template x-if="leaderboard.length !== 0">
              <table class="w-full">
                <thead>
                  <tr>
                    <th class="px-4">玩家</th>
                    <th class="px-4">最大方块</th>
                    <th class="px-4">得分</th>
                    <th class="px-4"></th>
                  </tr>
                </thead>
                <tbody class="divide-y divide-gray-200">
                  <template x-for="(player, index) in leaderboard" :key="index">
                    <tr>
                      <td class="px-4" x-text="player.username"></td>
                      <td class="px-4" x-text="`0x${Math.max(...player.board.flat()).toString(16).toUpperCase()}`"></td>
                      <td class="px-4" x-text="`0x${player.score.toString(16).toUpperCase()}`"></td>
                      <td class="px-4">
                        <button class="ml-2"
                          :class="isEditMode || autoMoveInterval ? 'text-gray-400' : 'text-blue-400 hover:text-blue-600'"
                          @click="loadLeaderboard(index); $nextTick(() => { showSettings = false })"
                          :disabled="isEditMode || autoMoveInterval">
                          加载盘面
                        </button>
                      </td>
                    </tr>
                  </template>
                </tbody>
              </table>
            </template>
          </div>
        </template>
        <template x-if="activeTab === '设置'">
          <div class="flex items-top justify-center" style="position: relative;">
            <template x-if="isEditMode || autoMoveInterval">
              <div class="absolute inset-0 z-10 flex items-center justify-center" style="backdrop-filter: blur(1px);">
                <div class="p-2 bg-gray-300 bg-opacity-75 rounded-xl text-white font-bold"
                  x-text="isEditMode ? '请先关闭编辑模式' : '请先关闭自动模式'"></div>
              </div>
            </template>
            <div class="mr-4">
              <label class="flex items-center mb-2">
                <input type="checkbox" class="mr-2" x-model="showScore" @change="saveSettings()">
                显示分数
              </label>
              <label class="flex items-center mb-2">
                <input type="checkbox" class="mr-2" x-model="showBoardSize" @change="saveSettings()">
                显示盘面大小
              </label>
              <label class="flex items-center mb-2">
                <input type="checkbox" class="mr-2" x-model="showBoardSizeSlider" @change="saveSettings()">
                显示盘面大小调整滑条
              </label>
              <label class="flex items-center mb-2">
                <input type="checkbox" class="mr-2" x-model="showUndoRedo" @change="saveSettings()">
                显示撤销、重做按钮
              </label>
              <label class="flex items-center mb-2">
                <input type="checkbox" class="mr-2" x-model="hiddenMode" @change="saveSettings()">
                隐藏大于 4 的块
              </label>
            </div>
            <div class="ml-4">
              <button class="block text-white m-2 py-1.5 px-3 rounded bg-blue-500 hover:bg-blue-600"
                @click="$nextTick(() => { showSerialization = true; serializationMode = 'output' })">
                导出盘面
              </button>
              <button class="block text-white m-2 py-1.5 px-3 rounded bg-blue-500 hover:bg-blue-600"
                @click="$nextTick(() => { showSerialization = true; serializationMode = 'input' })">
                导入盘面
              </button>
              <button class="block text-white m-2 py-1.5 px-3 rounded bg-blue-500 hover:bg-blue-600"
                @click="$nextTick(() => { showGameOver = true })">
                显示结算画面
              </button>
            </div>
          </div>
        </template>
      </div>
    </div>
  </div>
  <div
    class="absolute inset-0 z-20 bg-black bg-opacity-30 opacity-0 flex items-center justify-center transition-all duration-300 ease-in-out"
    :style="`opacity: ${ showSerialization ? '1' : '0' }; ${ showSerialization ? '' : 'pointer-events: none;' } backdrop-filter: blur(1px);`">
    <div class="bg-white rounded-lg shadow-lg p-4 text-lg" @click.away="if (!showGameOver) showSerialization = false">
      <div class="mb-4 flex flex-wrap justify-between items-center">
        <h2 class="text-xl font-bold">盘面序列化</h2>
        <button class="inline-block p-2 rounded-t-lg border-transparent text-sm text-gray-500 hover:text-red-500"
          @click="$nextTick(() => { showSerialization = false })" type="button" role="tab">
          关闭
        </button>
      </div>
      <template x-if="serializationMode === 'output'">
        <div class="serialization">
          <p class="mb-4">将以下文本复制到剪贴板，以保存当前盘面状态：</p>
          <label class="flex items-center">
            <input type="checkbox" class="mr-2" x-model="exportHistory"
              @change="$el.closest('div.serialization').querySelector('textarea').value = exportBoard()">
            导出历史记录
          </label>
          <textarea class="serialization p-2 bg-gray-100 rounded-lg break-words" x-text="exportBoard()" readonly
            @focus="$nextTick(() => $event.target.select())"></textarea>
          <div class="mt-4 text-right">
            <span style="color: green; display: none;">复制成功</span>
            <button class="text-white font-bold py-1.5 px-3 rounded bg-blue-500 hover:bg-blue-600" @click="
              navigator.clipboard.writeText($el.closest('div.serialization').querySelector('textarea').value);
              $el.closest('div').querySelector('span').style.display = 'inline';
              if ($el.x_timeout) clearTimeout($el.x_timeout);
              $el.x_timeout = setTimeout(() => { $el.closest('div').querySelector('span').style.display = 'none' }, 2000);
              ">
              复制
            </button>
          </div>
        </div>
      </template>
      <template x-if="serializationMode === 'input'">
        <div class="serialization">
          <p class="mb-4">将保存的盘面状态文本粘贴到下方输入框，然后点击“导入”按钮：</p>
          <label class="flex items-center">
            <input type="checkbox" class="mr-2" x-model="importHistory">
            导入历史记录
          </label>
          <textarea class="serialization p-2 bg-gray-100 rounded-lg break-words"
            @focus="$nextTick(() => $event.target.select())"></textarea>
          <div class=" mt-4 text-right">
            <button class="text-white font-bold py-1.5 px-3 rounded bg-blue-500 hover:bg-blue-600" @click="
              const textarea = $el.closest('div.serialization').querySelector('textarea');
              if (importBoard(textarea.value)) {
                textarea.value = '';
                $nextTick(() => { showSerialization = false });
              }
              ">
              导入
            </button>
          </div>
        </div>
      </template>
    </div>
  </div>
  <div
    class="absolute inset-0 z-30 bg-black bg-opacity-30 opacity-0 flex items-center justify-center transition-all duration-300 ease-in-out"
    :style="`opacity: ${ showGameOver ? '1' : '0' }; ${ showGameOver ? '' : 'pointer-events: none;' } backdrop-filter: blur(1px);`">
    <div class="bg-white rounded-lg shadow-lg p-4 text-lg" @click.away="showGameOver = false">
      <div class="mb-4 flex flex-wrap justify-between items-center">
        <h2 class="text-xl font-bold">游戏结束</h2>
        <button class="inline-block p-2 rounded-t-lg border-transparent text-sm text-gray-500 hover:text-red-500"
          @click="$nextTick(() => { showGameOver = false })" type="button" role="tab">
          关闭
        </button>
      </div>
      <div class="mb-4">
        <p>你合成出最大的数是
          <strong><span x-text="`0x${Math.max(...board.flat()).toString(16).toUpperCase()}`"></span></strong>。
        </p>
        <p>你的得分是 <strong><span x-text="`0x${score.toString(16).toUpperCase()}`"></span></strong>。</p>
        <p>你可以导出、编辑盘面，上传成绩，或者开始新游戏。</p>
      </div>
      <div class="mb-4 flex items-center">
        <label for="username" class="text-gray-600">你的名字：</label>
        <input type="text" id="username" name="username" x-model="username"
          class="flex-1 border-b border-gray-300 focus:border-blue-500"
          @focus="$nextTick(() => $event.target.select())">
        <button class="ml-2 text-blue-400 hover:text-blue-600"
          @click="uploadScore(); $nextTick(() => { showGameOver = false })">
          上传
        </button>
      </div>
      <div class="flex items-center justify-center">
        <button class="text-white font-bold m-2 py-1.5 px-3 rounded bg-blue-500 hover:bg-blue-600"
          @click="$nextTick(() => { showGameOver = false; showSerialization = true; serializationMode = 'output' })">
          导出
        </button>
        <button class="text-white font-bold m-2 py-1.5 px-3 rounded bg-blue-500 hover:bg-blue-600"
          @click="$nextTick(() => { showGameOver = false; resetGame() })">
          新游戏
        </button>
        <button class="text-white font-bold m-2 py-1.5 px-3 rounded bg-blue-500 hover:bg-blue-600"
          @click="$nextTick(() => { showGameOver = false; toggleEditMode() })">
          编辑
        </button>
      </div>
    </div>
  </div>

  <script>
    function game() {
      return {
        username: '',
        showGameOver: false,
        showSettings: false,
        activeTab: '教程',
        showScore: true,
        showBoardSize: true,
        showBoardSizeSlider: true,
        showUndoRedo: true,
        showSerialization: false,
        serializationMode: 'output',
        exportHistory: false,
        importHistory: false,
        hiddenMode: false,
        newGame: true,
        board: [],
        boardSize: 4,
        newBoardSize: 4,
        score: 0,
        scoreHex: '0x0',
        SCORE_MAX: 4294967296,
        NUM_MAX: 4294967296,
        isEditMode: false,
        editBoard: [],
        touchStartX: 0,
        touchStartY: 0,
        touchEndX: 0,
        touchEndY: 0,
        undoStack: [],
        redoStack: [],
        autoMoveInterval: null,
        leaderboard: [],

        saveSettings() {
          localStorage.setItem('settings', JSON.stringify({
            showScore: this.showScore,
            showBoardSize: this.showBoardSize,
            showBoardSizeSlider: this.showBoardSizeSlider,
            showUndoRedo: this.showUndoRedo,
            hiddenMode: this.hiddenMode,
          }));
        },

        saveBoard() {
          localStorage.setItem('board', this.exportBoard(false));
        },

        uploadScore() {
          fetch('https://copi143.eu.org:2048/upload', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              username: this.username,
              score: this.score,
              board: this.board,
              boardSize: this.boardSize,
            }),
          }).then(response => { }).catch(error => { alert(`Error: ${error}`) });
        },

        downloadLeaderboard(size = null) {
          size = size !== null ? size : this.boardSize;
          fetch(`https://copi143.eu.org:2048/leaderboard?size=${size}`).then(response => response.json()).then(data => { this.leaderboard = data }).catch(error => { alert(`Error: ${error}`) });
        },

        loadLeaderboard(index) {
          this.importBoard(JSON.stringify(this.leaderboard[index]), false);
        },

        initGame() {
          const settings = JSON.parse(localStorage.getItem('settings'));
          if (settings) {
            this.showScore = settings.showScore;
            this.showBoardSize = settings.showBoardSize;
            this.showBoardSizeSlider = settings.showBoardSizeSlider;
            this.showUndoRedo = settings.showUndoRedo;
            this.hiddenMode = settings.hiddenMode;
          }
          const board = localStorage.getItem('board');
          if (board) {
            this.importBoard(board, false);
          } else {
            this.resetGame();
          }
          this.undoStack = [];
          this.downloadLeaderboard();
        },

        resetGame(boardSize = null) {
          boardSize = boardSize !== null ? boardSize : parseInt(this.newBoardSize);
          const size_changed = this.boardSize != boardSize;
          this.updateHistory();
          this.newGame = true;
          this.boardSize = boardSize;
          this.board = Array(Number(this.boardSize)).fill().map(() => Array(Number(this.boardSize)).fill(0));
          this.score = 0;
          this.addNewTile();
          this.addNewTile();
          if (size_changed) this.downloadLeaderboard();
        },

        importBoard(serialized, import_history = null) {
          import_history = import_history !== null ? import_history : this.importHistory;
          try {
            const { board, score, boardSize, history } = JSON.parse(serialized);
            if (board.length !== boardSize || board.some(row => row.length !== boardSize)) {
              throw new Error('Invalid board size');
            }
            if (!import_history || history === undefined) this.updateHistory();
            this.board = board;
            this.score = score;
            this.boardSize = boardSize;
            this.newBoardSize = `${boardSize}`;
            if (import_history && history !== undefined) {
              this.undoStack = history.undo;
              this.redoStack = history.redo;
            }
            this.saveBoard();
            this.newGame = true;
            return true;
          } catch (error) {
            setTimeout(() => { alert('Invalid board data') }, 0);
            return false;
          }
        },

        exportBoard(export_history = null) {
          export_history = export_history !== null ? export_history : this.exportHistory;
          const data = {
            board: this.board,
            score: this.score,
            boardSize: this.boardSize,
          };
          if (export_history) data.history = { undo: this.undoStack, redo: this.redoStack };
          return JSON.stringify(data);
        },

        showGameOverMessage() {
          this.saveBoard();
          setTimeout(() => { this.showGameOver = true });
        },

        updateEditModeData() {
          this.scoreHex = `0x${this.score.toString(16).toUpperCase()}`;
          this.editBoard = this.board.map(row => row.map(cell => cell ? Math.floor(Math.log2(cell)) : 0));
        },

        toggleEditMode() {
          this.isEditMode = !this.isEditMode;
          if (this.isEditMode) {
            this.updateEditModeData();
          } else if (this.isGameOver()) {
            this.showGameOverMessage();
          }
        },

        editModeSetVal(row, col, value) {
          if (value !== this.editBoard[row][col]) {
            this.updateHistory();
            this.editBoard[row][col] = value;
            this.board[row][col] = value ? Math.pow(2, value) : 0;
          }
        },

        editModeInput(row, col, value) {
          value = value.replace(/[^0-9]/g, '');
          value = value ? parseInt(value) : 0;
          value = Math.min(value, Math.floor(Math.log2(this.NUM_MAX)));
          this.editModeSetVal(row, col, value);
        },

        editModeScoreInput(value) {
          value = value.replace(/[^0-9A-Fa-f]/g, '');
          value = value ? parseInt(value, 16) : 0;
          value = Math.min(value, this.SCORE_MAX);
          this.score = value;
          this.scoreHex = `0x${this.score.toString(16).toUpperCase()}`;
        },

        updateHistory(board = this.board, score = this.score) {
          if (this.newGame && this.redoStack.length == 0) {
            this.undoStack = [];
            this.newGame = false;
          }
          this.undoStack.push({ board, score });
          this.redoStack = [];
        },

        undo() {
          if (this.undoStack.length > 0) {
            this.redoStack.push({ board: this.board, score: this.score });
            const { board, score } = this.undoStack.pop();
            this.board = board;
            this.score = score;
            if (this.isEditMode) {
              this.updateEditModeData();
            }
          }
        },

        redo() {
          if (this.redoStack.length > 0) {
            this.undoStack.push({ board: this.board, score: this.score });
            const { board, score } = this.redoStack.pop();
            this.board = board;
            this.score = score;
            if (this.isEditMode) {
              this.updateEditModeData();
            }
          }
        },

        addNewTile() {
          const emptyCells = [];
          for (let i = 0; i < this.boardSize; i++) {
            for (let j = 0; j < this.boardSize; j++) {
              if (this.board[i][j] === 0) {
                emptyCells.push({ i, j });
              }
            }
          }
          if (emptyCells.length > 0) {
            const { i, j } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            this.board[i][j] = Math.random() < 0.9 ? 2 : 4;
          }
          if (!this.autoMoveInterval) {
            this.saveBoard();
          }
        },

        handleTouchStart(event) {
          if (this.isEditMode || this.autoMoveInterval || this.showSettings || this.showGameOver) return;
          event.preventDefault();
          this.touchStartX = event.changedTouches[0].screenX;
          this.touchStartY = event.changedTouches[0].screenY;
        },

        handleTouchEnd(event) {
          if (this.isEditMode || this.autoMoveInterval || this.showSettings || this.showGameOver) return;
          event.preventDefault();
          this.touchEndX = event.changedTouches[0].screenX;
          this.touchEndY = event.changedTouches[0].screenY;
          this.handleTouchDirection();
        },

        handleTouchDirection() {
          if (this.isEditMode || this.autoMoveInterval || this.showSettings || this.showGameOver) return;
          const deltaX = this.touchEndX - this.touchStartX;
          const deltaY = this.touchEndY - this.touchStartY;

          let direction = null;
          if (Math.abs(deltaX) > Math.abs(deltaY)) {
            if (deltaX > 10) {
              direction = 'right';
            } else if (deltaX < -10) {
              direction = 'left';
            }
          } else {
            if (deltaY > 10) {
              direction = 'down';
            } else if (deltaY < -10) {
              direction = 'up';
            }
          }

          if (direction === null) return;

          if (this.move(direction) && this.isGameOver()) {
            this.showGameOverMessage();
          }
        },

        handleKeyPress(event) {
          if (this.isEditMode || this.autoMoveInterval || this.showSettings || this.showGameOver) return;
          const key = event.key.toLowerCase();

          if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(key)) {
            event.preventDefault();
            let direction;
            switch (key) {
              case 'arrowup':
              case 'w':
                direction = 'up';
                break;
              case 'arrowdown':
              case 's':
                direction = 'down';
                break;
              case 'arrowleft':
              case 'a':
                direction = 'left';
                break;
              case 'arrowright':
              case 'd':
                direction = 'right';
                break;
            }

            if (this.move(direction) && this.isGameOver()) {
              alert('Game Over!');
            }
          }
        },

        move(direction) {
          const oldBoard = this.board.map(row => row.slice());
          const oldScore = this.score;

          let moved = false;
          const reverse = ['up', 'right'].includes(direction);
          const transpose = ['up', 'down'].includes(direction);

          let board = this.board;
          if (transpose) {
            board = this.transposeBoard(board);
          }

          for (let i = 0; i < this.boardSize; i++) {
            const row = reverse ? board[i].slice().reverse() : board[i];
            const newRow = this.mergeRow(row);
            if (!moved && newRow.some((val, idx) => val !== row[idx])) {
              moved = true;
            }
            board[i] = reverse ? newRow.reverse() : newRow;
          }

          if (transpose) {
            board = this.transposeBoard(board);
          }

          this.board = board;

          if (moved) {
            this.updateHistory(oldBoard, oldScore);
            this.addNewTile();
          }

          return moved;
        },

        mergeRow(row) {
          const newRow = row.filter(cell => cell !== 0);
          for (let i = 0; i < newRow.length - 1; i++) {
            if (newRow[i] === newRow[i + 1] && newRow[i] * 2 <= this.NUM_MAX) {
              newRow[i] *= 2;
              this.score += newRow[i];
              this.score = Math.min(this.score, this.SCORE_MAX);
              newRow.splice(i + 1, 1);
            }
          }
          while (newRow.length < this.boardSize) {
            newRow.push(0);
          }
          return newRow;
        },

        transposeBoard(board) {
          return board.map((_, colIndex) => board.map(row => row[colIndex]));
        },

        isGameOver() {
          for (let i = 0; i < this.boardSize; i++) {
            for (let j = 0; j < this.boardSize; j++) {
              if (this.board[i][j] === 0) {
                return false;
              }
              if (
                (i < this.boardSize - 1 && this.board[i][j] === this.board[i + 1][j]) ||
                (j < this.boardSize - 1 && this.board[i][j] === this.board[i][j + 1])
              ) {
                return false;
              }
            }
          }
          return true;
        },

        getCellClass(value) {
          const baseClasses = this.autoMoveInterval ? '' : 'transition-all duration-100 ease-in-out';
          if (value === 0) return `${baseClasses} bg-gray-200`;
          if (!this.isEditMode && this.hiddenMode && value > 4) return `${baseClasses} bg-gray-400`;
          const colorClasses = [
            'bg-yellow-200', 'bg-yellow-300', 'bg-yellow-400', 'bg-yellow-500',
            'bg-orange-200', 'bg-orange-300', 'bg-orange-400', 'bg-orange-500',
            'bg-red-200', 'bg-red-300', 'bg-red-400', 'bg-red-500',
            'bg-pink-200', 'bg-pink-300', 'bg-pink-400', 'bg-pink-500',
            'bg-purple-200', 'bg-purple-300', 'bg-purple-400', 'bg-purple-500',
          ];
          const colorIndex = Math.min(Math.floor(Math.log2(value)) - 1, colorClasses.length - 1);
          return `${baseClasses} ${colorClasses[colorIndex]} text-gray-800`;
        },

        getCellStyle(value) {
          if (value === 0) return `font-size: 0px;`;
          if (this.isEditMode || this.hiddenMode) return 'font-size: 20px;';
          if (value >= 0x10000) return 'font-size: 20px;';
          const fontSize = 60 / (Math.floor(Math.log2(value) / 4) + 3);
          return `font-size: ${fontSize}px;`;
        },

        getCellText(value) {
          if (this.hiddenMode && value > 4) return 'X';
          if (value >= 0x10000) return `2<sup>${Math.floor(Math.log2(value))}</sup>`;
          return `0x${value.toString(16).toUpperCase()}`;
        },

        toggleAutoMove() {
          if (this.autoMoveInterval === null) {
            this.startAutoMove();
          } else {
            this.stopAutoMove();
          }
        },

        startAutoMove() {
          this.autoMoveInterval = setInterval(() => { this.autoMove() }, 0);
        },

        stopAutoMove() {
          clearInterval(this.autoMoveInterval);
          this.autoMoveInterval = null;
          this.saveBoard();
        },

        autoMove() {
          const move = getNextMove(this.board);
          if (move === null) {
            this.stopAutoMove();
            return;
          }
          if (this.move(move) && this.isGameOver()) {
            this.stopAutoMove();
            this.showGameOverMessage();
          }
        },
      };
    }
  </script>
  <script>
    function getNextMove(board) {
      const size = board.length;
      const NUM_MAX = 4294967296;

      const directions = ['up', 'down', 'left', 'right'];

      function moveBoard(board, direction) {
        let newBoard = board.map(row => row.slice());
        let moved = false;

        const reverse = ['up', 'right'].includes(direction);
        const transpose = ['up', 'down'].includes(direction);

        if (transpose) {
          newBoard = transposeBoard(newBoard);
        }

        for (let i = 0; i < size; i++) {
          const row = reverse ? newBoard[i].slice().reverse() : newBoard[i];
          const newRow = mergeRow(row);
          if (!moved && newRow.some((val, idx) => val !== row[idx])) {
            moved = true;
          }
          newBoard[i] = reverse ? newRow.reverse() : newRow;
        }

        if (transpose) {
          newBoard = transposeBoard(newBoard);
        }

        return [moved, newBoard];
      }

      function mergeRow(row) {
        const newRow = [];
        let i = 0;
        while (i < row.length - 1) {
          if (row[i] === 0) { i++; continue; }
          if (row[i] === row[i + 1] && row[i] * 2 <= NUM_MAX) {
            newRow.push(row[i] * 2); i += 2;
          } else {
            newRow.push(row[i]); i++;
          }
        }
        if (i < row.length) newRow.push(row[row.length - 1]);
        while (newRow.length < size) {
          newRow.push(0);
        }
        return newRow;
      }

      function transposeBoard(board) {
        return board.map((_, colIndex) => board.map(row => row[colIndex]));
      }

      function calcScores(board) {
        if (size === 4) {
          let score = 0;
          let maxNum = 0;
          for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
              maxNum = Math.max(board[i][j], maxNum);
              if (board[i][j] === 0) {
                score++;
              } else if (i + 1 < size && board[i][j] === board[i + 1][j] || j + 1 < size && board[i][j] === board[i][j + 1]) {
                score++;
              }
            }
          }
          if (maxNum > 4) {
            for (let i = 0; i < size; i++) {
              if (board[i][0] === maxNum || board[i][size - 1] === maxNum) {
                score++;
              }
            }
            for (let j = 0; j < size; j++) {
              if (board[0][j] === maxNum || board[size - 1][j] === maxNum) {
                score++;
              }
            }
          }
          return score;
        }
        let score = 0;
        let maxNum = 0;
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            maxNum = Math.max(board[i][j], maxNum);
            if (board[i][j] === 0) {
              score += 1;
              if (i + 1 < size && board[i + 1][j] === 0) {
                score += 3;
              }
              if (j + 1 < size && board[i][j + 1] === 0) {
                score += 3;
              }
            } else {
              if (board[i][j] == 2) {
                if ((i - 1 < 0 || (board[i - 1][j] !== 0 && board[i - 1][j] !== 2))
                  && (i + 1 >= size || (board[i + 1][j] !== 0 && board[i + 1][j] !== 2))
                  && (j - 1 < 0 || (board[i][j - 1] !== 0 && board[i][j - 1] !== 2))
                  && (j + 1 >= size || (board[i][j + 1] !== 0 && board[i][j + 1] !== 2))) {
                  score -= 3;
                }
              } else if (i + 1 < size && board[i][j] === board[i + 1][j]
                || j + 1 < size && board[i][j] === board[i][j + 1]
              ) {
                score += 5;
              }
            }
          }
        }
        if (maxNum > 2) {
          for (let i = 0; i < size; i++) {
            if (board[i][0] === maxNum || board[i][size - 1] === maxNum) {
              score += 6;
            }
          }
          for (let j = 0; j < size; j++) {
            if (board[0][j] === maxNum || board[size - 1][j] === maxNum) {
              score += 6;
            }
          }
        }
        return score;
      }

      function getBestMove(board, depth) {
        if (depth === 0) {
          return [null, calcScores(board)];
        }

        let bestMove = null;
        let maxScore = -1048576;

        for (const direction of directions) {
          const [moved, newBoard] = moveBoard(board, direction);
          if (!moved) continue;
          const emptyCells = [];
          for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
              if (newBoard[i][j] === 0) {
                emptyCells.push({ i, j });
              }
            }
          }
          const scores = [];
          for (const { i, j } of emptyCells) {
            let board = newBoard.map(row => row.slice());
            board[i][j] = 2;
            const [_, score] = getBestMove(board, depth - 1);
            scores.push(score);
          }
          const finalScore = Math.min(...scores) + scores.reduce((a, b) => a + b, 0) / scores.length;
          if (finalScore > maxScore) {
            maxScore = finalScore;
            bestMove = direction;
          }
        }

        return [bestMove, bestMove ? maxScore : calcScores(board)];
      }


      if (size === 4) {
        const [bestMove] = getBestMove(board, 3);
        return bestMove || null;
      }

      let bestMove = null;
      let maxScore = -1048576;

      for (const direction of directions) {
        const [moved, newBoard] = moveBoard(board, direction);
        if (!moved) continue;
        const score = calcScores(newBoard);
        if (score > maxScore) {
          maxScore = score;
          bestMove = direction;
        }
      }

      return bestMove || null;
    }
  </script>
</body>

</html>