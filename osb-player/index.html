<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
  <script src="jszip.js"></script>
  <style>
    img {
      user-select: none;

      -webkit-user-drag: none;
      -khtml-user-drag: none;
      -moz-user-drag: none;
      -o-user-drag: none;
      user-drag: none;
    }

    body {
      overflow: hidden;

      margin: 0;
      padding: 0;

      background-color: #000;
    }

    #body {
      position: relative;

      display: none;
      overflow: hidden;

      width: 640px;
      height: 480px;
    }

    #Background,
    #Fail,
    #Pass,
    #Foreground {
      position: absolute;

      overflow: hidden;

      width: 100%;
      height: 100%;
    }

    #Background>div,
    #Fail>div,
    #Pass>div,
    #Foreground>div {
      overflow: hidden;
    }

    #Background>div>img,
    #Fail>div>img,
    #Pass>div>img,
    #Foreground>div>img {
      position: absolute;
      top: 0;
      left: 0;

      display: block;

      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <div id="body">
    <div id="Background"></div>
    <div id="Fail"></div>
    <div id="Pass"></div>
    <div id="Foreground"></div>
  </div>
  <input type="file" id="fileInput" style="margin: 10px; font-size: xx-large;" />
  <script>
    window.onload = window.onresize = function () {
      var div = document.getElementById('body');
      var scale = Math.min(window.innerWidth / 640, window.innerHeight / 480);
      div.style.width = 640 * scale + 'px';
      div.style.height = 480 * scale + 'px';
      document.body.style.marginLeft = (window.innerWidth - 640 * scale) / 2 + 'px';
      document.body.style.marginTop = (window.innerHeight - 480 * scale) / 2 + 'px';
    };

    const files = {};
    let storyboard = [];
    let storyboard_by_starttime = [];
    let storyboard_by_endtime = [];
    let storyboard_elements = {};
    let playStartTime = 0;
    let audio = null;
    const body = document.getElementById('body');
    const queue = { start: [], stop: [], now: [] };
    const containers = {
      'Background': document.getElementById('Background'),
      'Fail': document.getElementById('Fail'),
      'Pass': document.getElementById('Pass'),
      'Foreground': document.getElementById('Foreground'),
    };

    const imageURLs = {};
    function getSbImageURL(filepath) {
      if (!imageURLs[filepath]) {
        imageURLs[filepath] = URL.createObjectURL(new Blob([files[filepath]]));
      }
      return imageURLs[filepath];
    }

    function load_audio_file(content) {
      audio = new Audio(URL.createObjectURL(new Blob([content])));
      audio.onplay = function () {
        playStartTime = Date.now();
      };
      audio.onended = function () {
        playStartTime = -1;
      };
      audio.play();
    }

    function sbSetPosition(element, origin, x, y, w, h) {
      element.sb_pos_x = x;
      element.sb_pos_y = y;
      if (origin === null && !element.sb_origin) return;
      if (origin === null) {
        origin = element.sb_origin;
      } else {
        element.sb_origin = origin;
      }
      element.sb_x = x = x === null ? element.sb_x : x / 640 * 100;
      element.sb_y = y = y === null ? element.sb_y : y / 480 * 100;
      element.sb_w = w = w === null ? element.sb_w : w / 640 * 100;
      element.sb_h = h = h === null ? element.sb_h : h / 480 * 100;
      switch (origin) {
        case 'Centre': x -= w / 2; y -= h / 2; break;
        case 'CentreLeft': y -= h / 2; break;
        case 'TopRight': x -= w; break;
        case 'BottomCentre': x -= w / 2; y -= h; break;
        case 'TopCentre': x -= w / 2; break;
        case 'CentreRight': x -= w; y -= h / 2; break;
        case 'BottomLeft': y -= h; break;
        case 'BottomRight': x -= w; y -= h; break;
      }
      if (x !== element.sb_ox) element.style.left = x + '%';
      if (y !== element.sb_oy) element.style.top = y + '%';
      if (w !== element.sb_ow) element.style.width = w + '%';
      if (h !== element.sb_oh) element.style.height = h + '%';
      element.sb_ox = x;
      element.sb_oy = y;
      element.sb_ow = w;
      element.sb_oh = h;
    }

    function sbSetScale(element, x, y) {
      element.sb_scale_x = x;
      element.sb_scale_y = y;
      sbSetPosition(element, null, null, null, element.sb_rw * x, element.sb_rh * y);
    }

    const easing_functions = [
      x => x, // Linear
      x => Math.sin((x * Math.PI) / 2), // Easing Out
      x => 1 - Math.cos((x * Math.PI) / 2), // Easing In

      x => x * x, //
      x => 1 - (1 - x) * (1 - x), //
      x => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2, //

      x => x * x * x, //
      x => 1 - Math.pow(1 - x, 3), //
      x => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2, //

      x => x * x * x * x, //
      x => 1 - Math.pow(1 - x, 4), //
      x => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2, //

      x => x * x * x * x * x, //
      x => 1 - Math.pow(1 - x, 5), //
      x => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5), //

      x => 1 - Math.cos((x * Math.PI) / 2), //
      x => Math.sin((x * Math.PI) / 2), //
      x => -(Math.cos(Math.PI * x) - 1) / 2, //

      x => Math.pow(2, 10 * x - 10), //
      x => 1 - Math.pow(2, -10 * x), //
      x => x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2, //

      x => 1 - Math.sqrt(1 - Math.pow(x, 2)), //
      x => Math.sqrt(1 - Math.pow(x - 1, 2)), //
      x => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2, //

      x => -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * (2 * Math.PI / 3)), //
      x => Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * (2 * Math.PI / 3)) + 1, //
      x => x, //
      x => x, //
      x => x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * (2 * Math.PI / 4.5))) / 2 : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * (2 * Math.PI / 4.5))) / 2 + 1, //

      x => 2.70158 * x * x * x - 1.70158 * x * x, //
      x => 1 + 2.70158 * Math.pow(x - 1, 3) + 1.70158 * Math.pow(x - 1, 2), //
      x => x < 0.5 ? (Math.pow(2 * x, 2) * ((2.5949095 + 1) * 2 * x - 2.5949095)) / 2 : (Math.pow(2 * x - 2, 2) * ((2.5949095 + 1) * (x * 2 - 2) + 2.5949095) + 2) / 2, //

      x => 1 - (x => {
        const n1 = 7.5625;
        const d1 = 2.75;

        if (x < 1 / d1) {
          return n1 * x * x;
        } else if (x < 2 / d1) {
          return n1 * (x -= 1.5 / d1) * x + 0.75;
        } else if (x < 2.5 / d1) {
          return n1 * (x -= 2.25 / d1) * x + 0.9375;
        } else {
          return n1 * (x -= 2.625 / d1) * x + 0.984375;
        }
      })(1 - x), //
      x => {
        const n1 = 7.5625;
        const d1 = 2.75;

        if (x < 1 / d1) {
          return n1 * x * x;
        } else if (x < 2 / d1) {
          return n1 * (x -= 1.5 / d1) * x + 0.75;
        } else if (x < 2.5 / d1) {
          return n1 * (x -= 2.25 / d1) * x + 0.9375;
        } else {
          return n1 * (x -= 2.625 / d1) * x + 0.984375;
        }
      }, //
      x => {
        const f = x => {
          const n1 = 7.5625;
          const d1 = 2.75;

          if (x < 1 / d1) {
            return n1 * x * x;
          } else if (x < 2 / d1) {
            return n1 * (x -= 1.5 / d1) * x + 0.75;
          } else if (x < 2.5 / d1) {
            return n1 * (x -= 2.25 / d1) * x + 0.9375;
          } else {
            return n1 * (x -= 2.625 / d1) * x + 0.984375;
          }
        };
        return x < 0.5 ? (1 - f(1 - 2 * x)) / 2 : (1 + f(2 * x - 1)) / 2;
      }, //
    ];

    function sbInterpolation(v1, v2, starttime, endtime, time, easing) {
      if (time >= endtime || endtime === starttime) return v2;
      if (time <= starttime) return v1;
      const t = (time - starttime) / (endtime - starttime);
      return v1 + (v2 - v1) * easing_functions[easing](t);
    }

    function sbInterpolation2(x1, y1, x2, y2, starttime, endtime, time, easing) {
      if (time >= endtime || endtime === starttime) return { x: x2, y: y2 };
      if (time <= starttime) return { x: x1, y: y1 };
      const t = (time - starttime) / (endtime - starttime);
      return {
        x: x1 + (x2 - x1) * easing_functions[easing](t),
        y: y1 + (y2 - y1) * easing_functions[easing](t),
      };
    }

    function sbInterpolation3(x1, y1, z1, x2, y2, z2, starttime, endtime, time, easing) {
      if (time >= endtime || endtime === starttime) return { x: x2, y: y2, z: z2 };
      if (time <= starttime) return { x: x1, y: y1, z: z1 };
      const t = (time - starttime) / (endtime - starttime);
      return {
        x: x1 + (x2 - x1) * easing_functions[easing](t),
        y: y1 + (y2 - y1) * easing_functions[easing](t),
        z: z1 + (z2 - z1) * easing_functions[easing](t),
      };
    }

    const sbApplyColorMixCache = {};
    function sbApplyColorMix(element, r, g, b, is_add) {
      const name = JSON.stringify([element.sb_event.filepath, r, g, b])
      const entry = sbApplyColorMixCache[name];
      if (entry) {
        if (entry.status === 'ready') {
          if (!element.sb_img) {
            element.style.backgroundImage = `url(${entry.value})`;
          } else {
            element.sb_img.src = entry.value;
          }
          return;
        }
        entry.promise.then(url => {
          if (!element.sb_img) {
            element.style.backgroundImage = `url(${url})`;
          } else {
            element.sb_img.src = url;
          }
        });
        return;
      }
      let img = Promise.resolve(element.sb_img);
      if (!element.sb_img) {
        img = new Promise(resolve => {
          const img = new Image();
          img.onload = () => resolve(img);
          loadAnimation(element.sb_event).then(({ url }) => { img.src = url; });
        })
      }
      const promise = new Promise(resolve => {
        img.then(img => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = element.sb_rw;
          canvas.height = element.sb_rh;
          ctx.drawImage(img, 0, 0);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          if (is_add) {
            for (let i = 0; i < data.length; i += 4) {
              data[i] = Math.min(data[i] + r, 255);
              data[i + 1] = Math.min(data[i + 1] + g, 255);
              data[i + 2] = Math.min(data[i + 2] + b, 255);
              data[i + 3] = data[i + 3];
            }
          } else {
            for (let i = 0; i < data.length; i += 4) {
              data[i] *= r / 255;
              data[i + 1] *= g / 255;
              data[i + 2] *= b / 255;
              data[i + 3] = data[i + 3];
            }
          }
          ctx.putImageData(imageData, 0, 0);
          const url = canvas.toDataURL();
          sbApplyColorMixCache[name] = { status: 'ready', value: url };
          resolve(url);
        });
      });
      promise.then(url => {
        if (!element.sb_img) {
          element.style.backgroundImage = `url(${url})`;
        } else {
          element.sb_img.src = url;
        }
      });
      sbApplyColorMixCache[name] = { status: 'pending', promise };
    }

    // 图片大小必须相同
    const spriteSheets = {};
    async function createSpriteSheet(imageBuffers, name) {
      const sprite = spriteSheets[name];
      if (sprite) {
        if (sprite.status === 'ready') return Promise.resolve(sprite.value);
        return sprite.promise;
      }
      const promise = new Promise(resolve => {
        Promise.all(imageBuffers.map(buffer => new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = getSbImageURL(buffer);
        }))).then(images => {
          const canvas = document.createElement('canvas');
          canvas.width = images.reduce((sum, img) => sum + img.width, 0);
          canvas.height = Math.max(...images.map(img => img.height));
          const ctx = canvas.getContext('2d');
          images.reduce((xoff, img) => {
            ctx.drawImage(img, xoff, 0);
            return xoff + img.width;
          }, 0);
          canvas.toBlob(blob => {
            const value = {
              width: images[0].width,
              height: images[0].height,
              count: images.length,
              url: URL.createObjectURL(blob),
            };
            spriteSheets[name] = { status: 'ready', value };
            resolve(value);
          }, 'image/bmp');
        });
      });
      spriteSheets[name] = { status: 'pending', promise };
      return promise;
    }

    // 预加载动画对象
    async function loadAnimation(event) {
      const [basename, extname] = event.filepath.split('.');
      const imageBuffers = Array.from({ length: event.frameCount }, (_, n) => `${basename}${n}.${extname}`);
      return createSpriteSheet(imageBuffers, event.filepath);
    }

    function createStoryboardElement(event) {
      const e = document.createElement('div');
      e.sb_event = event;
      e.id = `storyboard-element-${event.id}`;
      e.sb_img = null;
      e.style.position = 'absolute';
      e.style.zIndex = event.id;
      e.style.display = 'none';
      e.sb_ready = false;
      e.sb_x = null;
      e.sb_y = null;
      e.sb_w = null;
      e.sb_h = null;
      e.sb_rw = null;
      e.sb_rh = null;
      e.sb_opacity = null;
      e.sb_pos_x = null;
      e.sb_pos_y = null;
      e.sb_scale_x = null;
      e.sb_scale_y = null;
      e.sb_transform = '';
      e.sb_color_r = null;
      e.sb_color_g = null;
      e.sb_color_b = null;
      e.sb_color_add = null;
      return e;
    }

    function createSpriteImg(event) {
      const div = createStoryboardElement(event);
      const img = document.createElement('img');
      div.sb_img = img;
      div.appendChild(img);
      img.src = event.type === 'Sprite' ? getSbImageURL(event.filepath) : '';
      img.onload = function () {
        div.sb_rw = img.naturalWidth;
        div.sb_rh = img.naturalHeight;
        sbSetPosition(div, event.origin, event.x, event.y, img.naturalWidth, img.naturalHeight);
        img.onload = null;
        storyboard_elements[event.id] = div;
      };
      return div;
    }

    function createAnimationDiv(event) {
      const div = createStoryboardElement(event);
      loadAnimation(event).then(({ width, height, count, url }) => {
        div.sb_rw = width;
        div.sb_rh = height;
        sbSetPosition(div, event.origin, event.x, event.y, width, height);
        div.style.backgroundSize = `${count * 100}% 100%`;
        const list = Array.from({ length: count }, (_, n) => `${n / count * 100}% { background-position-x: -${n * 100}%; }`);
        const keyframes = document.createElement('style');
        keyframes.innerHTML = `@keyframes storyboard-${event.id} { ${list.join(' ')} }`;
        div.appendChild(keyframes);
        const iteration = event.looptype === 'LoopForever' ? 'infinite' : '1';
        div.style.animation = `${event.frameDelay * count}ms steps(1) ${iteration} storyboard-${event.id}`;
        div.style.backgroundImage = `url(${url})`;
        storyboard_elements[event.id] = div;
      });
      return div;
    }

    function updateStoryboard() {
      if (playStartTime < 0) {
        playStartTime = 0;
        initStoryboard();
        audio.play();
        return;
      }
      if (playStartTime === 0) {
        requestAnimationFrame(updateStoryboard);
        return;
      }
      const time = Date.now() - playStartTime;
      while (queue.start.length && queue.start[0].starttime <= time + 1) {
        const event = queue.start.shift()
        containers[event.layer]?.appendChild(event.type === 'Sprite' ? createSpriteImg(event) : createAnimationDiv(event));
      }
      while (queue.stop.length && queue.stop[0].endtime <= time) {
        const event = queue.stop.shift()
        storyboard_elements[event.id]?.remove();
        delete storyboard_elements[event.id];
      }
      for (let id in storyboard_elements) {
        const element = storyboard_elements[id];
        const event = element.sb_event;
        let opacity = element.sb_opacity;
        let pos_x = element.sb_pos_x, pos_y = element.sb_pos_y;
        let scale_x = element.sb_scale_x, scale_y = element.sb_scale_y;
        let color_r = element.sb_color_r, color_g = element.sb_color_g, color_b = element.sb_color_b, color_add = element.sb_color_add;
        let transform = '';
        for (let cmd of event.commands) {
          if (element.sb_ready === false) {
            element.style.display = 'block';
            element.sb_ready = true;
          }
          switch (cmd.event) {
            case 'M': {
              const x1 = cmd.params[0];
              const y1 = cmd.params[1];
              const x2 = cmd.params[2];
              const y2 = cmd.params[3];
              const { x, y } = sbInterpolation2(x1, y1, x2, y2, cmd.starttime, cmd.endtime, time, cmd.easing);
              pos_x = x;
              pos_y = y;
              break;
            }
            case 'MX': {
              const x1 = cmd.params[0];
              const x2 = cmd.params[1];
              const x = sbInterpolation(x1, x2, cmd.starttime, cmd.endtime, time, cmd.easing);
              pos_x = x;
              break;
            }
            case 'MY': {
              const y1 = cmd.params[0];
              const y2 = cmd.params[1];
              const y = sbInterpolation(y1, y2, cmd.starttime, cmd.endtime, time, cmd.easing);
              pos_y = y;
              break;
            }
            case 'F': {
              const o1 = cmd.params[0];
              const o2 = cmd.params[1];
              const o = sbInterpolation(o1, o2, cmd.starttime, cmd.endtime, time, cmd.easing);
              opacity = o;
              break;
            }
            case 'S': {
              const v1 = cmd.params[0];
              const v2 = cmd.params[1];
              const v = sbInterpolation(v1, v2, cmd.starttime, cmd.endtime, time, cmd.easing);
              sbSetScale(element, v, v);
              scale_x = v;
              scale_y = v;
              break;
            }
            case 'V': {
              const x1 = cmd.params[0];
              const y1 = cmd.params[1];
              const x2 = cmd.params[2];
              const y2 = cmd.params[3];
              const { x, y } = sbInterpolation2(x1, y1, x2, y2, cmd.starttime, cmd.endtime, time, cmd.easing);
              scale_x = x;
              scale_y = y;
              break;
            }
            case 'R': {
              const r1 = cmd.params[0];
              const r2 = cmd.params[1];
              const r = sbInterpolation(r1, r2, cmd.starttime, cmd.endtime, time, cmd.easing);
              transform += ` rotate(${r}rad)`;
              break;
            }
            case 'C': {
              const r1 = cmd.params[0];
              const g1 = cmd.params[1];
              const b1 = cmd.params[2];
              const r2 = cmd.params[3];
              const g2 = cmd.params[4];
              const b2 = cmd.params[5];
              const { x, y, z } = sbInterpolation3(r1, g1, b1, r2, g2, b2, cmd.starttime, cmd.endtime, time, cmd.easing);
              color_r = x;
              color_g = y;
              color_b = z;
              break;
            }
            case 'P': {
              if (event.starttime < time || time > event.endtime) break;
              switch (cmd.params[0]) {
                case 'H': transform += ' scaleX(-1)'; break;
                case 'V': transform += ' scaleY(-1)'; break;
                case 'A': color_add = true; break;
              }
              break;
            }
          }
        }
        if (opacity !== element.sb_opacity) {
          element.style.opacity = opacity;
          element.sb_opacity = opacity;
        }
        if (pos_x !== element.sb_pos_x || pos_y !== element.sb_pos_y) {
          sbSetPosition(element, null, pos_x, pos_y, null, null);
        }
        if (scale_x !== element.sb_scale_x || scale_y !== element.sb_scale_y) {
          sbSetScale(element, scale_x, scale_y);
        }
        if (element.sb_transform !== transform) {
          element.style.transform = transform;
          element.sb_transform = transform;
        }
        if (color_r !== element.sb_color_r || color_g !== element.sb_color_g || color_b !== element.sb_color_b || color_add !== element.sb_color_add) {
          sbApplyColorMix(element, color_r, color_g, color_b, color_add);
          element.sb_color_r = color_r;
          element.sb_color_g = color_g;
          element.sb_color_b = color_b;
          element.sb_color_add = color_add;
        }
      }
      requestAnimationFrame(updateStoryboard);
    }

    function initStoryboard(objects = null) {
      if (objects !== null) {
        storyboard = objects;
        storyboard_by_starttime = objects.slice().sort((a, b) => a.starttime - b.starttime);
        storyboard_by_endtime = objects.slice().sort((a, b) => a.endtime - b.endtime);
      }
      for (let element in storyboard_elements) {
        storyboard_elements[element].remove();
      }
      storyboard_elements = {};
      queue.start = storyboard_by_starttime.slice();
      queue.stop = storyboard_by_endtime.slice();
      queue.now = [];
      updateStoryboard();
    }

    function load_osb_file(content) {
      const osb = new TextDecoder().decode(content);
      const lines = osb.split('\n').filter(line => line && !line.startsWith('//') && !line.startsWith('[')).map(line => `${line.match(/^(\s*)/)[0].length},${line.trim()}`).map(line => line.split(',').map(part => {
        part = part.trim();
        if (part.startsWith('"') && part.endsWith('"')) {
          return part.slice(1, -1);
        } else if (!isNaN(parseFloat(part))) {
          return parseFloat(part);
        } else {
          return part;
        }
      }));
      let next_id = 0;
      const objects = (lines => {
        const objects = [];
        let current = null;
        lines.forEach(line => {
          if (line[0] === 0) {
            if (line[1] !== 'Sprite' && line[1] !== 'Animation') console.log(`未实现：${line[1]}`);
            if (current) objects.push(current);
            current = [line.slice(1)];
          } else if (current) {
            current.push(line);
          }
        });
        if (current) objects.push(current);
        return objects;
      })(lines).map((object) => {
        const head = object[0];
        const data = object.slice(1);
        const event = {
          id: next_id++,
          type: head[0],
          layer: head[1],
          origin: head[2], // 图像的原点
          filepath: head[3].replace(/\\/g, '/'),
          x: head[4],
          y: head[5],
          commands: [],
        };
        if (head[0] === 'Animation') {
          event.frameCount = head[6];
          event.frameDelay = head[7];
          event.looptype = head[8];
        }
        const parse = (relative_time, nline) => {
          let line = data[nline];
          if (line[1] === 'L') { // Loop
            let starttime = relative_time + line[2];
            let loopcount = line[3];
            const indent = data[nline][0];
            let j = 0;
            let endtimes = [];
            for (let i = nline + 1; loopcount > 0;) {
              if (i >= data.length || data[i][0] <= indent) {
                j = i;
                i = nline + 1;
                starttime = endtimes.shift();
                endtimes = [];
                loopcount--;
                continue;
              }
              const [next_i, endtime] = parse(starttime, i);
              i = next_i;
              endtimes.push(endtime);
            }
            return [j, starttime];
          }
          const paranums = { 'F': 2, 'M': 4, 'MX': 2, 'MY': 2, 'S': 2, 'V': 4, 'R': 2, 'C': 6, 'P': 1 };
          const paranum = paranums[line[1]];
          if (!paranum) return;
          const event_data = {
            event: line[1],
            easing: line[2],
            starttime: relative_time + line[3],
            endtime: relative_time + (line[4] !== '' ? line[4] : line[3]),
          };
          let last_endtime = 0;
          line = line.slice(5);
          if (line.length < paranum) {
            for (let i = 0; line.length < paranum; i++) {
              line.push(line[i]);
            }
            const d = { ...event_data };
            d.params = line.slice();
            event.commands.push(d);
            last_endtime = event_data.endtime;
          } else {
            for (let i = 0; i < line.length / paranum; i++) {
              const d = { ...event_data };
              d.params = line.slice(i * paranum, (i + 1) * paranum);
              event.commands.push(d);
              last_endtime = event_data.endtime;
              const duration = event_data.endtime - event_data.starttime;
              event_data.starttime = event_data.endtime;
              event_data.endtime += duration;
            }
          }
          return [nline + 1, last_endtime];
        };
        for (let nline = 0; nline < data.length;) {
          nline = parse(0, nline)[0];
        }
        event.commands.sort((a, b) => a.endtime - b.endtime);
        event.starttime = Math.min(...event.commands.map(cmd => cmd.starttime));
        event.endtime = Math.max(...event.commands.map(cmd => cmd.endtime));
        return event;
      });
      const animations = objects.filter(obj => obj.type === 'Animation');
      Promise.all(animations.map(loadAnimation)).then(() => {
        initStoryboard(objects);
      });
    }

    function load_file(event) {
      const file = event.target.files[0];
      if (!file) return;
      document.getElementById('fileInput').style.display = 'none';
      document.getElementById('body').style.display = 'block';
      const reader = new FileReader();
      reader.onload = function (e) {
        const zip = new JSZip();
        zip.loadAsync(e.target.result).then(function (zip) {
          const promises = [];
          zip.forEach(function (relativePath, zipEntry) {
            const name = zipEntry.name;
            promises.push(zipEntry.async('arraybuffer').then((content) => {
              files[name] = content;
            }));
          });
          Promise.all(promises).then(() => {
            for (let name in files) {
              if (name.endsWith('.osb')) {
                load_osb_file(files[name]);
              }
              if (name.indexOf('/') === -1 && name.indexOf('\\') === -1 && (name.endsWith('.mp3') || name.endsWith('.m4a') || name.endsWith('.ogg') || name.endsWith('.oga'))) {
                load_audio_file(files[name]);
              }
            }
          });
        });
      };
      reader.readAsArrayBuffer(file);
    }

    document.getElementById('fileInput').addEventListener('change', load_file);
  </script>
</body>

</html>