<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
  <script src="jszip.js"></script>
  <style>
    img {
      user-select: none;
      -webkit-user-drag: none;
      -khtml-user-drag: none;
      -moz-user-drag: none;
      -o-user-drag: none;
      user-drag: none;
    }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
    }

    #body {
      position: relative;
      width: 640px;
      height: 480px;
      overflow: hidden;
      display: none;
    }

    #Background,
    #Fail,
    #Pass,
    #Foreground {
      position: absolute;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #Background>div,
    #Fail>div,
    #Pass>div,
    #Foreground>div {
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div id="body">
    <div id="Background"></div>
    <div id="Fail"></div>
    <div id="Pass"></div>
    <div id="Foreground"></div>
  </div>
  <input type="file" id="fileInput" style="margin: 10px; font-size: xx-large;" />
  <script>
    window.onload = window.onresize = function () {
      var div = document.getElementById('body');
      var scale = Math.min(window.innerWidth / 640, window.innerHeight / 480);
      div.style.width = 640 * scale + 'px';
      div.style.height = 480 * scale + 'px';
      document.body.style.marginLeft = (window.innerWidth - 640 * scale) / 2 + 'px';
      document.body.style.marginTop = (window.innerHeight - 480 * scale) / 2 + 'px';
    };

    const files = {};
    let storyboard = [];
    let storyboard_by_starttime = [];
    let storyboard_by_endtime = [];
    let storyboard_elements = {};
    let playStartTime = 0;
    let audio = null;
    const body = document.getElementById('body');
    const queue = { start: [], stop: [], now: [] };
    const containers = {
      'Background': document.getElementById('Background'),
      'Fail': document.getElementById('Fail'),
      'Pass': document.getElementById('Pass'),
      'Foreground': document.getElementById('Foreground'),
    };

    const imageURLs = {};
    function getSbImageURL(filepath) {
      if (!imageURLs[filepath]) {
        imageURLs[filepath] = URL.createObjectURL(new Blob([files[filepath]]));
      }
      return imageURLs[filepath];
    }

    function load_audio_file(content) {
      audio = new Audio(URL.createObjectURL(new Blob([content])));
      audio.onplay = function () {
        playStartTime = Date.now();
      };
      audio.onended = function () {
        playStartTime = -1;
      };
      audio.play();
    }

    function sbSetPosition(element, origin, x, y, w, h) {
      if (origin === null && !element.sb_origin) return;
      if (origin === null) {
        origin = element.sb_origin;
      } else {
        element.sb_origin = origin;
      }
      element.sb_x = x = x === null ? element.sb_x : x / 640 * 100;
      element.sb_y = y = y === null ? element.sb_y : y / 480 * 100;
      element.sb_w = w = w === null ? element.sb_w : w / 640 * 100;
      element.sb_h = h = h === null ? element.sb_h : h / 480 * 100;
      if (w === null || h === null) return;
      switch (origin) {
        case 'Centre': x -= w / 2; y -= h / 2; break;
        case 'CentreLeft': y -= h / 2; break;
        case 'TopRight': x -= w; break;
        case 'BottomCentre': x -= w / 2; y -= h; break;
        case 'TopCentre': x -= w / 2; break;
        case 'CentreRight': x -= w; y -= h / 2; break;
        case 'BottomLeft': y -= h; break;
        case 'BottomRight': x -= w; y -= h; break;
      }
      element.style.left = x + '%';
      element.style.top = y + '%';
      element.style.width = w + '%';
      element.style.height = h + '%';
    }

    function sbSetScale(element, x, y) {
      sbSetPosition(element, null, null, null, element.sb_rw * x, element.sb_rh * y);
    }

    function sbInterpolation(v1, v2, starttime, endtime, time, easing) {
      if (time >= endtime || endtime === starttime) return v2;
      if (time <= starttime) return v1;
      const t = (time - starttime) / (endtime - starttime);
      const lerp = (a, b, t) => a + (b - a) * t;
      return lerp(v1, v2, t);
    }

    function sbPosInterpolation(x1, y1, x2, y2, starttime, endtime, time, easing) {
      if (time >= endtime || endtime === starttime) return { x: x2, y: y2 };
      if (time <= starttime) return { x: x1, y: y1 };
      const t = (time - starttime) / (endtime - starttime);
      const lerp = (a, b, t) => a + (b - a) * t;
      return {
        x: lerp(x1, x2, t),
        y: lerp(y1, y2, t)
      };
    }

    // 图片大小必须相同
    const spriteSheets = {};
    async function createSpriteSheet(imageBuffers, name) {
      const sprite = spriteSheets[name];
      if (sprite) {
        if (sprite.status === 'ready') return Promise.resolve(sprite.value);
        return sprite.promise;
      }
      const promise = new Promise(resolve => {
        Promise.all(imageBuffers.map(buffer => new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = getSbImageURL(buffer);
        }))).then(images => {
          const canvas = document.createElement('canvas');
          canvas.width = images.reduce((sum, img) => sum + img.width, 0);
          canvas.height = Math.max(...images.map(img => img.height));
          const ctx = canvas.getContext('2d');
          images.reduce((xoff, img) => {
            ctx.drawImage(img, xoff, 0);
            return xoff + img.width;
          }, 0);
          canvas.toBlob(blob => {
            const value = {
              width: images[0].width,
              height: images[0].height,
              count: images.length,
              url: URL.createObjectURL(blob),
            };
            spriteSheets[name] = { status: 'ready', value };
            resolve(value);
          }, 'image/bmp');
        });
      });
      spriteSheets[name] = { status: 'pending', promise };
      return promise;
    }

    // 预加载动画对象
    async function loadAnimation(event) {
      const [basename, extname] = event.filepath.split('.');
      const imageBuffers = Array.from({ length: event.frameCount }, (_, n) => `${basename}${n}.${extname}`);
      return createSpriteSheet(imageBuffers, name);
    }

    function createStoryboardElement(tagName, event) {
      const e = document.createElement(tagName);
      e.sb_event = event;
      e.id = `storyboard-element-${event.id}`;
      e.style.position = 'absolute';
      e.style.zIndex = event.id;
      e.style.display = 'none';
      e.sb_ready = false;
      e.sb_x = null;
      e.sb_y = null;
      e.sb_w = null;
      e.sb_h = null;
      e.sb_rw = null;
      e.sb_rh = null;
      e.sb_transform = '';
      sbSetPosition(e, event.origin, event.x, event.y, null, null);
      return e;
    }

    function createSpriteImg(event) {
      const img = createStoryboardElement('img', event);
      img.src = event.type === 'Sprite' ? getSbImageURL(event.filepath) : '';
      img.onload = function () {
        img.sb_rw = img.naturalWidth;
        img.sb_rh = img.naturalHeight;
        sbSetScale(img, 1, 1);
        img.onload = null;
        storyboard_elements[event.id] = img;
      };
      return img;
    }

    function createAnimationDiv(event) {
      const div = createStoryboardElement('div', event);
      loadAnimation(event).then(({ width, height, count, url }) => {
        div.sb_rw = width;
        div.sb_rh = height;
        sbSetScale(div, 1, 1);
        div.style.backgroundSize = `${count * 100}% 100%`;
        const list = Array.from({ length: count }, (_, n) => `${n / count * 100}% { background-position-x: -${n * 100}%; }`);
        const keyframes = document.createElement('style');
        keyframes.innerHTML = `@keyframes storyboard-${event.id} { ${list.join(' ')} }`;
        div.appendChild(keyframes);
        const iteration = event.looptype === 'LoopForever' ? 'infinite' : '1';
        div.style.animation = `${event.frameDelay * count}ms steps(1) ${iteration} storyboard-${event.id}`;
        div.style.backgroundImage = `url(${url})`;
        storyboard_elements[event.id] = div;
      });
      return div;
    }

    function updateStoryboard() {
      if (playStartTime < 0) {
        playStartTime = 0;
        initStoryboard();
        audio.play();
        return;
      }
      if (playStartTime === 0) {
        requestAnimationFrame(updateStoryboard);
        return;
      }
      const time = Date.now() - playStartTime;
      while (queue.start.length && queue.start[0].starttime <= time + 1) {
        const event = queue.start.shift()
        containers[event.layer]?.appendChild(event.type === 'Sprite' ? createSpriteImg(event) : createAnimationDiv(event));
      }
      while (queue.stop.length && queue.stop[0].endtime <= time) {
        const event = queue.stop.shift()
        storyboard_elements[event.id]?.remove();
        delete storyboard_elements[event.id];
      }
      for (let id in storyboard_elements) {
        const element = storyboard_elements[id];
        const event = element.sb_event;
        let transform = '';
        for (let cmd of event.commands) {
          if (cmd.starttime > time) continue;
          if (element.sb_ready === false) {
            element.style.display = 'block';
            element.sb_ready = true;
          }
          switch (cmd.event) {
            case 'M': {
              const x1 = cmd.params[0];
              const y1 = cmd.params[1];
              const x2 = cmd.params[2];
              const y2 = cmd.params[3];
              const { x, y } = sbPosInterpolation(x1, y1, x2, y2, cmd.starttime, cmd.endtime, time, cmd.easing);
              sbSetPosition(element, event.origin, x, y, null, null);
              break;
            }
            case 'MX': {
              const x1 = cmd.params[0];
              const x2 = cmd.params[1];
              const x = sbInterpolation(x1, x2, cmd.starttime, cmd.endtime, time, cmd.easing);
              sbSetPosition(element, event.origin, x, null, null, null);
              break;
            }
            case 'MY': {
              const y1 = cmd.params[0];
              const y2 = cmd.params[1];
              const y = sbInterpolation(y1, y2, cmd.starttime, cmd.endtime, time, cmd.easing);
              sbSetPosition(element, event.origin, null, y, null, null);
              break;
            }
            case 'F': {
              const o1 = cmd.params[0];
              const o2 = cmd.params[1];
              const o = sbInterpolation(o1, o2, cmd.starttime, cmd.endtime, time, cmd.easing);
              element.style.opacity = o;
              break;
            }
            case 'S': {
              const v1 = cmd.params[0];
              const v2 = cmd.params[1];
              const v = sbInterpolation(v1, v2, cmd.starttime, cmd.endtime, time, cmd.easing);
              sbSetScale(element, v, v);
              break;
            }
            case 'V': {
              const x1 = cmd.params[0];
              const y1 = cmd.params[1];
              const x2 = cmd.params[2];
              const y2 = cmd.params[3];
              const { x, y } = sbPosInterpolation(x1, y1, x2, y2, cmd.starttime, cmd.endtime, time, cmd.easing);
              sbSetScale(element, x, y);
              break;
            }
            case 'R': {
              const r1 = cmd.params[0];
              const r2 = cmd.params[1];
              const r = sbInterpolation(r1, r2, cmd.starttime, cmd.endtime, time, cmd.easing);
              transform += ` rotate(${r}rad)`;
              break;
            }
            case 'C': {
              const r1 = cmd.params[0];
              const g1 = cmd.params[1];
              const b1 = cmd.params[2];
              const r2 = cmd.params[3];
              const g2 = cmd.params[4];
              const b2 = cmd.params[5];
              const r = sbInterpolation(r1, r2, cmd.starttime, cmd.endtime, time, cmd.easing);
              const g = sbInterpolation(g1, g2, cmd.starttime, cmd.endtime, time, cmd.easing);
              const b = sbInterpolation(b1, b2, cmd.starttime, cmd.endtime, time, cmd.easing);
              element.style.filter = `rgb(${r}, ${g}, ${b})`;
              break;
            }
            case 'P': {
              switch (cmd.params[0]) {
                case 'H': transform += ' scaleX(-1)'; break;
                case 'V': transform += ' scaleY(-1)'; break;
                case 'A': /* 暂时不支持 */ break;
              }
              break;
            }
          }
        }
        if (element.sb_transform !== transform) {
          element.style.transform = transform;
          element.sb_transform = transform;
        }
      }
      requestAnimationFrame(updateStoryboard);
    }

    function initStoryboard(objects = null) {
      if (objects !== null) {
        storyboard = objects;
        storyboard_by_starttime = objects.slice().sort((a, b) => a.starttime - b.starttime);
        storyboard_by_endtime = objects.slice().sort((a, b) => a.endtime - b.endtime);
      }
      for (let element in storyboard_elements) {
        storyboard_elements[element].remove();
      }
      storyboard_elements = {};
      queue.start = storyboard_by_starttime.slice();
      queue.stop = storyboard_by_endtime.slice();
      queue.now = [];
      updateStoryboard();
    }

    function load_osb_file(content) {
      const osb = new TextDecoder().decode(content);
      const lines = osb.split('\n').filter(line => line && !line.startsWith('//') && !line.startsWith('[')).map(line => `${line.match(/^(\s*)/)[0].length},${line.trim()}`).map(line => line.split(',').map(part => {
        part = part.trim();
        if (part.startsWith('"') && part.endsWith('"')) {
          return part.slice(1, -1);
        } else if (!isNaN(parseFloat(part))) {
          return parseFloat(part);
        } else {
          return part;
        }
      }));
      let next_id = 0;
      const objects = (lines => {
        const objects = [];
        let current = null;
        lines.forEach(line => {
          if (line[0] === 0) {
            if (line[1] !== 'Sprite' && line[1] !== 'Animation') console.log(`未实现：${line[1]}`);
            if (current) objects.push(current);
            current = [line.slice(1)];
          } else if (current) {
            current.push(line);
          }
        });
        if (current) objects.push(current);
        return objects;
      })(lines).map((object) => {
        const head = object[0];
        const data = object.slice(1);
        const event = {
          id: next_id++,
          type: head[0],
          layer: head[1],
          origin: head[2], // 图像的原点
          filepath: head[3].replace(/\\/g, '/'),
          x: head[4],
          y: head[5],
          commands: [],
        };
        if (head[0] === 'Animation') {
          event.frameCount = head[6];
          event.frameDelay = head[7];
          event.looptype = head[8];
        }
        const parse = (relative_time, nline) => {
          let line = data[nline];
          if (line[1] === 'L') { // Loop
            let starttime = relative_time + line[2];
            let loopcount = line[3];
            const indent = data[nline][0];
            let j = 0;
            let endtimes = [];
            for (let i = nline + 1; loopcount > 0;) {
              if (i >= data.length || data[i][0] <= indent) {
                j = i;
                i = nline + 1;
                starttime = Math.max(...endtimes);
                endtimes = [];
                loopcount--;
                continue;
              }
              const [next_i, endtime] = parse(starttime, i);
              i = next_i;
              endtimes.push(endtime);
            }
            return [j, starttime];
          }
          const paranums = { 'F': 2, 'M': 4, 'MX': 2, 'MY': 2, 'S': 2, 'V': 4, 'R': 2, 'C': 6, 'P': 1 };
          const paranum = paranums[line[1]];
          if (!paranum) return;
          const event_data = {
            event: line[1],
            easing: line[2],
            starttime: relative_time + line[3],
            endtime: relative_time + (line[4] !== '' ? line[4] : line[3]),
          };
          let last_endtime = 0;
          line = line.slice(5);
          if (line.length < paranum) {
            for (let i = 0; line.length < paranum; i++) {
              line.push(line[i]);
            }
            const d = { ...event_data };
            d.params = line;
            event.commands.push(d);
            last_endtime = event_data.endtime;
          } else {
            for (let i = 0; i < line.length / paranum; i++) {
              const d = { ...event_data };
              d.params = line.slice(i * paranum, (i + 1) * paranum);
              event.commands.push(d);
              last_endtime = event_data.endtime;
              const duration = event_data.endtime - event_data.starttime;
              event_data.starttime = event_data.endtime;
              event_data.endtime += duration;
            }
          }
          return [nline + 1, last_endtime];
        };
        for (let nline = 0; nline < data.length;) {
          nline = parse(0, nline)[0];
        }
        event.starttime = Math.min(...event.commands.map(cmd => cmd.starttime));
        event.endtime = Math.max(...event.commands.map(cmd => cmd.endtime));
        return event;
      });
      const animations = objects.filter(obj => obj.type === 'Animation');
      Promise.all(animations.map(loadAnimation)).then(() => {
        initStoryboard(objects);
      });
    }

    function load_file(event) {
      const file = event.target.files[0];
      if (!file) return;
      document.getElementById('fileInput').style.display = 'none';
      document.getElementById('body').style.display = 'block';
      const reader = new FileReader();
      reader.onload = function (e) {
        const zip = new JSZip();
        zip.loadAsync(e.target.result).then(function (zip) {
          const promises = [];
          zip.forEach(function (relativePath, zipEntry) {
            const name = zipEntry.name;
            promises.push(zipEntry.async('arraybuffer').then((content) => {
              files[name] = content;
            }));
          });
          Promise.all(promises).then(() => {
            for (let name in files) {
              if (name.endsWith('.osb')) {
                load_osb_file(files[name]);
              }
              if (name.indexOf('/') === -1 && name.indexOf('\\') === -1 && (name.endsWith('.mp3') || name.endsWith('.m4a') || name.endsWith('.ogg') || name.endsWith('.oga'))) {
                load_audio_file(files[name]);
              }
            }
          });
        });
      };
      reader.readAsArrayBuffer(file);
    }

    document.getElementById('fileInput').addEventListener('change', load_file);
  </script>
</body>

</html>